import type { GridRowTreeNodeConfig, GridRowId } from '../../../models';
import { GridRowGroupingResult } from '../../core/rowGroupsPerProcessing';

export type GridNodeNameToIdTree = {
  [nodeName: string]: { id: GridRowId; children: GridNodeNameToIdTree };
};

interface InsertRowInTreeParams {
  result: GridRowGroupingResult;
  path: string[];
  id: GridRowId;
  defaultGroupingExpansionDepth: number;
  nodeNameToIdTree: GridNodeNameToIdTree;
}

export const insertRowInTree = (params: InsertRowInTreeParams) => {
  const { result, path, id, defaultGroupingExpansionDepth, nodeNameToIdTree } = params;

  let nodeNameToIdSubTree = nodeNameToIdTree;
  let parentNode: GridRowTreeNodeConfig | null = null;

  for (let depth = 0; depth < path.length; depth += 1) {
    const nodeName = path[depth];
    let nodeId: GridRowId;

    const expanded = defaultGroupingExpansionDepth === -1 || defaultGroupingExpansionDepth > depth;

    let nodeNameConfig = nodeNameToIdSubTree[nodeName];

    if (!nodeNameConfig) {
      nodeId =
        depth === path.length - 1 ? id : `auto-generated-row-${path.slice(0, depth + 1).join('-')}`;

      nodeNameConfig = { id: nodeId, children: {} };
      nodeNameToIdSubTree[nodeName] = nodeNameConfig;
    } else {
      nodeId = nodeNameConfig.id;
    }
    nodeNameToIdSubTree = nodeNameConfig.children;

    if (depth < path.length - 1) {
      let node = result.tree[nodeId] ?? null;
      if (!node) {
        node = {
          id: nodeId,
          isAutoGenerated: true,
          expanded,
          children: [],
          parent: parentNode?.id ?? null,
          label: path[depth],
          depth,
        };

        result.tree[nodeId] = node;
        result.idRowsLookup[nodeId] = {};
        result.rowIds.push(nodeId);
      }
    } else {
      result.tree[id] = {
        id,
        expanded,
        parent: parentNode?.id ?? null,
        label: path[depth],
        depth,
      };
    }

    if (parentNode != null) {
      if (!parentNode.children) {
        parentNode.children = [];
      }

      parentNode.children.push(nodeId);
    }

    parentNode = result.tree[nodeId]!;
  }

  result.treeDepth = Math.max(result.treeDepth, path.length);
};
