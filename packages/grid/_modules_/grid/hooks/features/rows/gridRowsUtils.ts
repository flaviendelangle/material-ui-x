import type { GridRowTreeNodeConfig, GridRowId } from '../../../models';
import { GridRowGroupingResult, GridRowGroupParams } from '../../core/rowGroupsPerProcessing';

type GridNodeNameToIdTree = {
  [nodeName: string]: { id: GridRowId; children: GridNodeNameToIdTree };
};

interface GenerateRowTreeParams extends GridRowGroupParams {
  rows: { id: GridRowId; path: string[] }[];
  defaultGroupingExpansionDepth: number;
}

export const generateRowTree = (params: GenerateRowTreeParams) => {
  const result: GridRowGroupingResult = {
    tree: {},
    treeDepth: 1,
    idRowsLookup: { ...params.idRowsLookup },
    rowIds: [...params.rowIds],
  };

  const nodeNameToIdTree: GridNodeNameToIdTree = {};

  params.rows.forEach((row) => {
    let nodeNameToIdSubTree = nodeNameToIdTree;
    let parentNode: GridRowTreeNodeConfig | null = null;

    for (let depth = 0; depth < row.path.length; depth += 1) {
      const nodeName = row.path[depth];
      let nodeId: GridRowId;

      const expanded =
        params.defaultGroupingExpansionDepth === -1 || params.defaultGroupingExpansionDepth > depth;

      let nodeNameConfig = nodeNameToIdSubTree[nodeName];

      if (!nodeNameConfig) {
        nodeId =
          depth === row.path.length - 1
            ? row.id
            : `auto-generated-row-${row.path.slice(0, depth + 1).join('-')}`;

        nodeNameConfig = { id: nodeId, children: {} };
        nodeNameToIdSubTree[nodeName] = nodeNameConfig;
      } else {
        nodeId = nodeNameConfig.id;
      }
      nodeNameToIdSubTree = nodeNameConfig.children;

      if (depth < row.path.length - 1) {
        let node = result.tree[nodeId] ?? null;
        if (!node) {
          node = {
            id: nodeId,
            isAutoGenerated: true,
            expanded,
            children: [],
            parent: parentNode?.id ?? null,
            label: row.path[depth],
            depth,
          };

          result.tree[nodeId] = node;
          result.idRowsLookup[nodeId] = {};
          result.rowIds.push(nodeId);
        }

        node.descendantCount = (node.descendantCount ?? 0) + 1;
      } else {
        result.tree[row.id] = {
          id,
          expanded,
          parent: parentNode?.id ?? null,
          label: row.path[depth],
          depth,
        };
      }

      if (parentNode != null) {
        if (!parentNode.children) {
          parentNode.children = [];
        }

        // TODO: Avoid linear complexity here
        if (!parentNode.children.includes(nodeId)) {
          parentNode.children.push(nodeId);
        }
      }

      parentNode = result.tree[nodeId]!;
    }

    result.treeDepth = Math.max(result.treeDepth, row.path.length);
  });

  return result;
};
